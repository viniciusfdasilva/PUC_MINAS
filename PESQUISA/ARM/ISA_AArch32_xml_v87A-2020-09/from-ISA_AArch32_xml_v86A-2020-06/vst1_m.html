<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><link href="insn.css" rel="stylesheet" type="text/css"/><meta content="iform.xsl" name="generator"/><title>VST1 (multiple single elements) -- AArch32</title></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="a32_encindex.html">A32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="t32_encindex.html">T32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">VST1 (multiple single elements)</h2><p class="desc"><p class="aml">Store multiple single elements from one, two, three, or four registers stores elements to memory from one, two, three, or four registers, without interleaving.  Every element of each register is stored. For details of the addressing mode see <a class="armarm-xref" title="Reference to Armv8 ARM section">Advanced SIMD addressing mode</a>.</p><p class="aml">Depending on settings in the <a class="armarm-xref" title="Reference to Armv8 ARM section">CPACR</a>, <a class="armarm-xref" title="Reference to Armv8 ARM section">NSACR</a>, and <a class="armarm-xref" title="Reference to Armv8 ARM section">HCPTR</a> registers, and the Security state and PE mode in which the instruction is executed, an attempt to execute the instruction might be <span class="arm-defined-word">undefined</span>, or trapped to Hyp mode. For more information see <a class="armarm-xref" title="Reference to Armv8 ARM section">Enabling Advanced SIMD and floating-point support</a>.</p></p><p class="desc">
      It has encodings from the following instruction sets:
       A32 (
      <a href="#a1">A1</a>
      , 
      <a href="#a2">A2</a>
      , 
      <a href="#a3">A3</a>
       and 
      <a href="#a4">A4</a>
      )
       and 
       T32 (
      <a href="#t1">T1</a>
      , 
      <a href="#t2">T2</a>
      , 
      <a href="#t3">T3</a>
       and 
      <a href="#t4">T4</a>
      )
      .
    </p><h3 class="classheading"><a id="a1" name="a1"></a>A1</h3><p class="desc"></p><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td class="r">0</td><td class="lr">D</td><td class="lr">0</td><td class="lr">0</td><td class="lr" colspan="4">Rn</td><td class="lr" colspan="4">Vd</td><td class="l">0</td><td>1</td><td>1</td><td class="r">1</td><td class="lr" colspan="2">size</td><td class="lr" colspan="2">align</td><td class="lr" colspan="4">Rm</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Offset<span class="bitdiff"> (Rm == 1111)</span></h4><p class="asm-code"><a id="VST1_m_A1_nowb" name="VST1_m_A1_nowb"></a>VST1{<a href="#c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}]</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm == 1101)</span></h4><p class="asm-code"><a id="VST1_m_A1_posti" name="VST1_m_A1_posti"></a>VST1{<a href="#c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}]!</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm != 11x1)</span></h4><p class="asm-code"><a id="VST1_m_A1_postr" name="VST1_m_A1_postr"></a>VST1{<a href="#c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}], <a href="#rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm></a></p></div><p class="pseudocode">regs = 1;  if align&lt;1> == '1' then UNDEFINED;
alignment = if align == '00' then 1 else 4 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(align);
ebytes = 1 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size);  elements = 8 DIV ebytes;
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
wback = (m != 15);  register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;</p><h3>CONSTRAINED UNPREDICTABLE behavior</h3><p>If <span class="pseudocode">d+regs > 32</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The memory locations specified by the instruction and the number of registers specified by the instruction become <span class="arm-defined-word">unknown</span>. If the instruction specifies writeback, then that register becomes <span class="arm-defined-word">unknown</span>. This behavior does not affect any other memory locations.</li></ul><h3 class="classheading"><a id="a2" name="a2"></a>A2</h3><p class="desc"></p><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td class="r">0</td><td class="lr">D</td><td class="lr">0</td><td class="lr">0</td><td class="lr" colspan="4">Rn</td><td class="lr" colspan="4">Vd</td><td class="l">1</td><td>0</td><td>1</td><td class="r">0</td><td class="lr" colspan="2">size</td><td class="lr" colspan="2">align</td><td class="lr" colspan="4">Rm</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Offset<span class="bitdiff"> (Rm == 1111)</span></h4><p class="asm-code"><a id="VST1_m_A2_nowb" name="VST1_m_A2_nowb"></a>VST1{<a href="#c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}]</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm == 1101)</span></h4><p class="asm-code"><a id="VST1_m_A2_posti" name="VST1_m_A2_posti"></a>VST1{<a href="#c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}]!</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm != 11x1)</span></h4><p class="asm-code"><a id="VST1_m_A2_postr" name="VST1_m_A2_postr"></a>VST1{<a href="#c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}], <a href="#rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm></a></p></div><p class="pseudocode">regs = 2;  if align == '11' then UNDEFINED;
alignment = if align == '00' then 1 else 4 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(align);
ebytes = 1 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size);  elements = 8 DIV ebytes;
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
wback = (m != 15);  register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;</p><h3>CONSTRAINED UNPREDICTABLE behavior</h3><p>If <span class="pseudocode">d+regs > 32</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The memory locations specified by the instruction and the number of registers specified by the instruction become <span class="arm-defined-word">unknown</span>. If the instruction specifies writeback, then that register becomes <span class="arm-defined-word">unknown</span>. This behavior does not affect any other memory locations.</li></ul><h3 class="classheading"><a id="a3" name="a3"></a>A3</h3><p class="desc"></p><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td class="r">0</td><td class="lr">D</td><td class="lr">0</td><td class="lr">0</td><td class="lr" colspan="4">Rn</td><td class="lr" colspan="4">Vd</td><td class="l">0</td><td>1</td><td>1</td><td class="r">0</td><td class="lr" colspan="2">size</td><td class="lr" colspan="2">align</td><td class="lr" colspan="4">Rm</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Offset<span class="bitdiff"> (Rm == 1111)</span></h4><p class="asm-code"><a id="VST1_m_A3_nowb" name="VST1_m_A3_nowb"></a>VST1{<a href="#c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}]</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm == 1101)</span></h4><p class="asm-code"><a id="VST1_m_A3_posti" name="VST1_m_A3_posti"></a>VST1{<a href="#c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}]!</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm != 11x1)</span></h4><p class="asm-code"><a id="VST1_m_A3_postr" name="VST1_m_A3_postr"></a>VST1{<a href="#c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}], <a href="#rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm></a></p></div><p class="pseudocode">regs = 3;  if align&lt;1> == '1' then UNDEFINED;
alignment = if align == '00' then 1 else 4 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(align);
ebytes = 1 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size);  elements = 8 DIV ebytes;
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
wback = (m != 15);  register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;</p><h3>CONSTRAINED UNPREDICTABLE behavior</h3><p>If <span class="pseudocode">d+regs > 32</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The memory locations specified by the instruction and the number of registers specified by the instruction become <span class="arm-defined-word">unknown</span>. If the instruction specifies writeback, then that register becomes <span class="arm-defined-word">unknown</span>. This behavior does not affect any other memory locations.</li></ul><h3 class="classheading"><a id="a4" name="a4"></a>A4</h3><p class="desc"></p><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td class="r">0</td><td class="lr">D</td><td class="lr">0</td><td class="lr">0</td><td class="lr" colspan="4">Rn</td><td class="lr" colspan="4">Vd</td><td class="l">0</td><td>0</td><td>1</td><td class="r">0</td><td class="lr" colspan="2">size</td><td class="lr" colspan="2">align</td><td class="lr" colspan="4">Rm</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Offset<span class="bitdiff"> (Rm == 1111)</span></h4><p class="asm-code"><a id="VST1_m_A4_nowb" name="VST1_m_A4_nowb"></a>VST1{<a href="#c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}]</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm == 1101)</span></h4><p class="asm-code"><a id="VST1_m_A4_posti" name="VST1_m_A4_posti"></a>VST1{<a href="#c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}]!</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm != 11x1)</span></h4><p class="asm-code"><a id="VST1_m_A4_postr" name="VST1_m_A4_postr"></a>VST1{<a href="#c_1" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}], <a href="#rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm></a></p></div><p class="pseudocode">regs = 4;
alignment = if align == '00' then 1 else 4 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(align);
ebytes = 1 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size);  elements = 8 DIV ebytes;
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
wback = (m != 15);  register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;</p><h3>CONSTRAINED UNPREDICTABLE behavior</h3><p>If <span class="pseudocode">d+regs > 32</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The memory locations specified by the instruction and the number of registers specified by the instruction become <span class="arm-defined-word">unknown</span>. If the instruction specifies writeback, then that register becomes <span class="arm-defined-word">unknown</span>. This behavior does not affect any other memory locations.</li></ul><h3 class="classheading"><a id="t1" name="t1"></a>T1</h3><p class="desc"></p><div class="regdiagram-16x2"><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td class="r">0</td><td class="lr">D</td><td class="lr">0</td><td class="lr">0</td><td class="lr" colspan="4">Rn</td><td class="lr" colspan="4">Vd</td><td class="l">0</td><td>1</td><td>1</td><td class="r">1</td><td class="lr" colspan="2">size</td><td class="lr" colspan="2">align</td><td class="lr" colspan="4">Rm</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Offset<span class="bitdiff"> (Rm == 1111)</span></h4><p class="asm-code"><a id="VST1_m_T1_nowb" name="VST1_m_T1_nowb"></a>VST1{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}]</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm == 1101)</span></h4><p class="asm-code"><a id="VST1_m_T1_posti" name="VST1_m_T1_posti"></a>VST1{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}]!</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm != 11x1)</span></h4><p class="asm-code"><a id="VST1_m_T1_postr" name="VST1_m_T1_postr"></a>VST1{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}], <a href="#rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm></a></p></div><p class="pseudocode">regs = 1;  if align&lt;1> == '1' then UNDEFINED;
alignment = if align == '00' then 1 else 4 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(align);
ebytes = 1 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size);  elements = 8 DIV ebytes;
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
wback = (m != 15);  register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;</p><h3>CONSTRAINED UNPREDICTABLE behavior</h3><p>If <span class="pseudocode">d+regs > 32</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The memory locations specified by the instruction and the number of registers specified by the instruction become <span class="arm-defined-word">unknown</span>. If the instruction specifies writeback, then that register becomes <span class="arm-defined-word">unknown</span>. This behavior does not affect any other memory locations.</li></ul><h3 class="classheading"><a id="t2" name="t2"></a>T2</h3><p class="desc"></p><div class="regdiagram-16x2"><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td class="r">0</td><td class="lr">D</td><td class="lr">0</td><td class="lr">0</td><td class="lr" colspan="4">Rn</td><td class="lr" colspan="4">Vd</td><td class="l">1</td><td>0</td><td>1</td><td class="r">0</td><td class="lr" colspan="2">size</td><td class="lr" colspan="2">align</td><td class="lr" colspan="4">Rm</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Offset<span class="bitdiff"> (Rm == 1111)</span></h4><p class="asm-code"><a id="VST1_m_T2_nowb" name="VST1_m_T2_nowb"></a>VST1{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}]</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm == 1101)</span></h4><p class="asm-code"><a id="VST1_m_T2_posti" name="VST1_m_T2_posti"></a>VST1{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}]!</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm != 11x1)</span></h4><p class="asm-code"><a id="VST1_m_T2_postr" name="VST1_m_T2_postr"></a>VST1{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}], <a href="#rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm></a></p></div><p class="pseudocode">regs = 2;  if align == '11' then UNDEFINED;
alignment = if align == '00' then 1 else 4 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(align);
ebytes = 1 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size);  elements = 8 DIV ebytes;
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
wback = (m != 15);  register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;</p><h3>CONSTRAINED UNPREDICTABLE behavior</h3><p>If <span class="pseudocode">d+regs > 32</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The memory locations specified by the instruction and the number of registers specified by the instruction become <span class="arm-defined-word">unknown</span>. If the instruction specifies writeback, then that register becomes <span class="arm-defined-word">unknown</span>. This behavior does not affect any other memory locations.</li></ul><h3 class="classheading"><a id="t3" name="t3"></a>T3</h3><p class="desc"></p><div class="regdiagram-16x2"><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td class="r">0</td><td class="lr">D</td><td class="lr">0</td><td class="lr">0</td><td class="lr" colspan="4">Rn</td><td class="lr" colspan="4">Vd</td><td class="l">0</td><td>1</td><td>1</td><td class="r">0</td><td class="lr" colspan="2">size</td><td class="lr" colspan="2">align</td><td class="lr" colspan="4">Rm</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Offset<span class="bitdiff"> (Rm == 1111)</span></h4><p class="asm-code"><a id="VST1_m_T3_nowb" name="VST1_m_T3_nowb"></a>VST1{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}]</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm == 1101)</span></h4><p class="asm-code"><a id="VST1_m_T3_posti" name="VST1_m_T3_posti"></a>VST1{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}]!</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm != 11x1)</span></h4><p class="asm-code"><a id="VST1_m_T3_postr" name="VST1_m_T3_postr"></a>VST1{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}], <a href="#rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm></a></p></div><p class="pseudocode">regs = 3;  if align&lt;1> == '1' then UNDEFINED;
alignment = if align == '00' then 1 else 4 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(align);
ebytes = 1 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size);  elements = 8 DIV ebytes;
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
wback = (m != 15);  register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;</p><h3>CONSTRAINED UNPREDICTABLE behavior</h3><p>If <span class="pseudocode">d+regs > 32</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The memory locations specified by the instruction and the number of registers specified by the instruction become <span class="arm-defined-word">unknown</span>. If the instruction specifies writeback, then that register becomes <span class="arm-defined-word">unknown</span>. This behavior does not affect any other memory locations.</li></ul><h3 class="classheading"><a id="t4" name="t4"></a>T4</h3><p class="desc"></p><div class="regdiagram-16x2"><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td class="r">0</td><td class="lr">D</td><td class="lr">0</td><td class="lr">0</td><td class="lr" colspan="4">Rn</td><td class="lr" colspan="4">Vd</td><td class="l">0</td><td>0</td><td>1</td><td class="r">0</td><td class="lr" colspan="2">size</td><td class="lr" colspan="2">align</td><td class="lr" colspan="4">Rm</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Offset<span class="bitdiff"> (Rm == 1111)</span></h4><p class="asm-code"><a id="VST1_m_T4_nowb" name="VST1_m_T4_nowb"></a>VST1{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}]</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm == 1101)</span></h4><p class="asm-code"><a id="VST1_m_T4_posti" name="VST1_m_T4_posti"></a>VST1{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}]!</p></div><div class="encoding"><h4 class="encoding">Post-indexed<span class="bitdiff"> (Rm != 11x1)</span></h4><p class="asm-code"><a id="VST1_m_T4_postr" name="VST1_m_T4_postr"></a>VST1{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>}.<a href="#size" title="Data size (field &quot;size&quot;) [8,16,32,64]">&lt;size></a> <a href="#list" title="List containing the 64-bit names of SIMD&amp;FP registers (field &quot;D:Vd&quot;)">&lt;list></a>, [<a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn></a>{:<a href="#align" title="Optional alignment (field &quot;align&quot;)">&lt;align></a>}], <a href="#rm" title="General-purpose index register containing an offset applied after the access (field &quot;Rm&quot;)">&lt;Rm></a></p></div><p class="pseudocode">regs = 4;
alignment = if align == '00' then 1 else 4 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(align);
ebytes = 1 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size);  elements = 8 DIV ebytes;
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
wback = (m != 15);  register_index = (m != 15 &amp;&amp; m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;</p><h3>CONSTRAINED UNPREDICTABLE behavior</h3><p>If <span class="pseudocode">d+regs > 32</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The memory locations specified by the instruction and the number of registers specified by the instruction become <span class="arm-defined-word">unknown</span>. If the instruction specifies writeback, then that register becomes <span class="arm-defined-word">unknown</span>. This behavior does not affect any other memory locations.</li></ul><p class="encoding-notes"><p class="aml">For more information about the <span class="arm-defined-word">constrained unpredictable</span> behavior of this instruction, see <a class="armarm-xref" title="Reference to Armv8 ARM section">Architectural Constraints on UNPREDICTABLE behaviors</a>, and particularly <a class="armarm-xref" title="Reference to Armv8 ARM section">VST1 (multiple single elements)</a>.</p><p class="aml">Related encodings: See <a class="armarm-xref" title="Reference to Armv8 ARM section">Advanced SIMD element or structure load/store</a> for the T32 instruction set, or <a class="armarm-xref" title="Reference to Armv8 ARM section">Advanced SIMD element or structure load/store</a> for the A32 instruction set.</p></p><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;c></td><td><a id="c_1" name="c_1"></a><p class="aml">For encoding A1, A2, A3 and A4: see <a class="armarm-xref" title="Reference to Armv8 ARM section">Standard assembler syntax fields</a>. This encoding must be unconditional.</p></td></tr><tr><td></td><td><a id="c" name="c"></a><p class="aml">For encoding T1, T2, T3 and T4: see <a class="armarm-xref" title="Reference to Armv8 ARM section">Standard assembler syntax fields</a>.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;q></td><td><a id="q" name="q"></a><p class="aml">See <a class="armarm-xref" title="Reference to Armv8 ARM section">Standard assembler syntax fields</a>.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;size></td><td><a id="size" name="size"></a>
        Is the data size, 
    encoded in 
    <q>size</q>:
      
        <table class="valuetable"><thead><tr><th class="bitfield">size</th><th class="symbol">&lt;size></th></tr></thead><tbody><tr><td class="bitfield">00</td><td class="symbol">8</td></tr><tr><td class="bitfield">01</td><td class="symbol">16</td></tr><tr><td class="bitfield">10</td><td class="symbol">32</td></tr><tr><td class="bitfield">11</td><td class="symbol">64</td></tr></tbody></table></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;list></td><td><a id="list" name="list"></a><p class="aml">Is a list containing the 64-bit names of the SIMD&amp;FP registers.</p><p class="aml">The list must be one of:</p><dl><dt>{ &lt;Dd> }</dt><dd>Single register. Selects the A1 and T1 encodings of the instruction.</dd><dt>{ &lt;Dd>, &lt;Dd+1> }</dt><dd>Two single-spaced registers. Selects the A2 and T2 encodings of the instruction.</dd><dt>{ &lt;Dd>, &lt;Dd+1>, &lt;Dd+2> }</dt><dd>Three single-spaced registers. Selects the A3 and T3 encodings of the instruction.</dd><dt>{ &lt;Dd>, &lt;Dd+1>, &lt;Dd+2>, &lt;Dd+3> }</dt><dd>Four single-spaced registers. Selects the A4 and T4 encodings of the instruction.</dd></dl><p class="aml">The register &lt;Dd> is encoded in the "D:Vd" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Rn></td><td><a id="rn" name="rn"></a><p class="aml">Is the general-purpose base register, encoded in the "Rn" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;align></td><td><a id="align" name="align"></a><p class="aml">Is the optional alignment.</p><p class="aml">Whenever &lt;align> is omitted, the standard alignment is used, see <a class="armarm-xref" title="Reference to Armv8 ARM section">Unaligned data access</a>, and is encoded in the "align" field as 0b00.</p><p class="aml">Whenever &lt;align> is present, the permitted values are:</p><dl><dt>64</dt><dd>64-bit alignment, encoded in the "align" field as 0b01.</dd><dt>128</dt><dd>128-bit alignment, encoded in the "align" field as 0b10. Available only if &lt;list> contains two or four registers.</dd><dt>256</dt><dd>256-bit alignment, encoded in the "align" field as 0b11. Available only if &lt;list> contains four registers.</dd></dl><p class="aml">: is the preferred separator before the &lt;align> value, but the alignment can be specified as @&lt;align>, see <a class="armarm-xref" title="Reference to Armv8 ARM section">Advanced SIMD addressing mode</a>.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Rm></td><td><a id="rm" name="rm"></a><p class="aml">Is the general-purpose index register containing an offset applied after the access, encoded in the "Rm" field.</p></td></tr></table></div><p class="syntax-notes"><p class="aml">For more information about &lt;Rn>, !, and &lt;Rm>, see <a class="armarm-xref" title="Reference to Armv8 ARM section">Advanced SIMD addressing mode</a>.</p></p><div class="ps" psname="execute"><a id="execute" name="execute"></a><h3 class="pseudocode">Operation</h3><p class="pseudocode">if <a href="shared_pseudocode.html#impl-aarch32.ConditionPassed.0" title="function: boolean ConditionPassed()">ConditionPassed</a>() then
    EncodingSpecificOperations();  <a href="shared_pseudocode.html#impl-aarch32.CheckAdvSIMDEnabled.0" title="function: CheckAdvSIMDEnabled()">CheckAdvSIMDEnabled</a>();
    address = <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[n];  iswrite = TRUE;
    - = <a href="shared_pseudocode.html#AArch32.CheckAlignment.4" title="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype, boolean iswrite)">AArch32.CheckAlignment</a>(address, alignment, <a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_VEC</a>, iswrite);
    for r = 0 to regs-1
        for e = 0 to elements-1
            if ebytes != 8 then
                <a href="shared_pseudocode.html#impl-aarch32.MemU.write.2" title="accessor: MemU[bits(32) address, integer size] = bits(8*size) value">MemU</a>[address,ebytes] = <a href="shared_pseudocode.html#impl-shared.Elem.read.2" title="accessor: bits(size) Elem[bits(N) vector, integer e]">Elem</a>[<a href="shared_pseudocode.html#impl-aarch32.D.read.1" title="accessor: bits(64) D[integer n]">D</a>[d+r],e];
            else
                - = <a href="shared_pseudocode.html#AArch32.CheckAlignment.4" title="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype, boolean iswrite)">AArch32.CheckAlignment</a>(address, ebytes, <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_NORMAL</a>, iswrite);
                bits(64) data = <a href="shared_pseudocode.html#impl-shared.Elem.read.2" title="accessor: bits(size) Elem[bits(N) vector, integer e]">Elem</a>[<a href="shared_pseudocode.html#impl-aarch32.D.read.1" title="accessor: bits(64) D[integer n]">D</a>[d+r],e];
                <a href="shared_pseudocode.html#impl-aarch32.MemU.write.2" title="accessor: MemU[bits(32) address, integer size] = bits(8*size) value">MemU</a>[address,4] = if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccType acctype)">BigEndian</a><ins>(</ins><del>() then data&lt;63:32> else data&lt;31:0>;</del><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><ins>) then data&lt;63:32> else data&lt;31:0>;
                </ins><a href="shared_pseudocode.html#impl-aarch32.MemU.write.2" title="accessor: MemU[bits(32) address, integer size] = bits(8*size) value">MemU</a>[address+4,4] = if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccType acctype)">BigEndian</a><ins>(</ins><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><ins>) then data&lt;31:0> else data&lt;63:32>;
</ins><del>() then data&lt;31:0> else data&lt;63:32>;
</del>            address = address + ebytes;
    if wback then
        if register_index then
            <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[n] = <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[n] + <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[m];
        else
            <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[n] = <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[n] + 8*regs;</p></div><hr/><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="a32_encindex.html">A32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="t32_encindex.html">T32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa <ins>v01_19</ins><del>v01_15</del>, pseudocode <ins>v2020-09_xml</ins><del>v2020-06_rel</del>, sve <ins>v2020-09_rc3</ins><del>v2020-06-29-gc9614a3</del>
      ; Build timestamp: <ins>2020-09-30T21</ins><del>2020-07-03T11</del>:<ins>35</ins><del>36</del>
    </p><p class="copyconf">
      Copyright  2010-2020 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>